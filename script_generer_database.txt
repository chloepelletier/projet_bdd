/*
SELECT Concat('DROP TRIGGER ', Trigger_Name, ';') FROM  information_schema.TRIGGERS WHERE TRIGGER_SCHEMA = 'your_schema';
Pour drop tous triggers. Doit utiliser une scheme (connais pas)
*/
use basketballer;
DROP TRIGGER type_action_lancer;
DROP TRIGGER assiste_panier;
DROP TRIGGER date_coherentes;
DROP TRIGGER max_1_dossard;
DROP TRIGGER max_1_contrat;
DROP TRIGGER joueur_bonne_equipe;
DROP DATABASE basketballer;
create database basketballer;
use basketballer;

show tables;


CREATE TABLE equipe (num_equipe int, nom_equipe char(20), ville char(20), pays char(20), 
	fondation date, PRIMARY KEY(num_equipe));

CREATE TABLE joueur (id_joueur int, prenom char(20),
	nom_famille char(20), naissance date, taille_ft  real, poids_lbs real,
	role char(20), est_droitier bool, dist_bras_ft real,
	PRIMARY KEY(id_joueur));

CREATE TABLE partie (annee int, num_partie int, ville char(20), date_partie date,
	PRIMARY KEY(annee, num_partie));
/*DF date_partie -> annee.
  Ajouter est_serie bool ? (Redondant)
*/

CREATE TABLE serie (annee int, num_serie int, PRIMARY KEY(annee, num_serie));

CREATE TABLE appartient(annee int, num_partie int, num_serie int, num_sous_serie int,
	PRIMARY KEY(annee, num_partie),
	FOREIGN KEY(annee, num_partie) REFERENCES partie(annee, num_partie) ON DELETE CASCADE,
	FOREIGN KEY(annee, num_serie) REFERENCES serie(annee, num_serie) ON DELETE CASCADE);

CREATE TABLE type_action(type char(20), PRIMARY KEY(type));
INSERT INTO type_action VALUES ("lancer"), ("revirement"), ("faute"), ("rebond");

CREATE TABLE action (annee int, num_partie int, instant time, type_action char(20), id_joueur int,
	PRIMARY KEY(annee, num_partie, instant),
	FOREIGN KEY(annee, num_partie) REFERENCES partie(annee, num_partie) ON DELETE CASCADE,
	FOREIGN KEY(type_action) REFERENCES type_action(type) ON DELETE CASCADE,
	FOREIGN KEY(id_joueur) REFERENCES joueur(id_joueur) ON DELETE CASCADE);
/* Spécialisation totale pas implémentée (impossible?)
*/

CREATE TABLE type_lancer(type char(20), PRIMARY KEY(type));
INSERT INTO type_lancer VALUES ("1pt"), ("2pt"), ("3pt");

CREATE TABLE lancer (annee int, num_partie int, instant time, type_lancer char(20), est_panier bool,
	PRIMARY KEY(annee, num_partie, instant),
	FOREIGN KEY(type_lancer) REFERENCES type_lancer(type),
	FOREIGN KEY(annee, num_partie, instant) REFERENCES action(annee, num_partie, instant)
		ON DELETE CASCADE);

delimiter //
CREATE TRIGGER type_action_lancer
BEFORE INSERT ON lancer
FOR EACH ROW
BEGIN
	IF (
		SELECT type_action
		FROM action
		WHERE annee = NEW.annee AND num_partie = NEW.num_partie AND instant = NEW.instant)
	 <> "lancer"
	THEN SET NEW.instant = null;
	END IF;
END;//
delimiter ;
/* Ajouter 1 autre pour update?
   Ajouter un de ce genre pour chaque spécialisation d'action :(
*/

/*
 Trigger pour le type de lancer OU table des types???
 Prefere table, mais trigger semble plus effiace.... 
 Si table, doit changer l'interface d'"assiste" et ajouter un trigger pour assister seulement des paniers
*/

CREATE TABLE assiste(id_joueur int, annee int, num_partie int, instant time,
	PRIMARY KEY(annee, num_partie, instant),
	FOREIGN KEY(annee, num_partie, instant) REFERENCES lancer(annee, num_partie, instant)
		ON DELETE CASCADE,
	FOREIGN KEY(id_joueur) REFERENCES joueur(id_joueur) ON DELETE CASCADE);

delimiter //
CREATE TRIGGER assiste_panier
BEFORE INSERT ON assiste
FOR EACH ROW
BEGIN
	IF (
		SELECT est_panier
		FROM lancer
		WHERE annee = NEW.annee AND num_partie = NEW.num_partie AND instant = NEW.instant)
	 = false
	THEN SET NEW.instant = null;
	END IF;
END;//
delimiter ;
/* Ajouter 1 autre pour update? */

CREATE TABLE type_faute(type char(20), PRIMARY KEY(type));
INSERT INTO type_faute VALUES ("offensif"), ("defensif");

CREATE TABLE revirement (annee int, num_partie int, instant time, type_revirement char(20),
	PRIMARY KEY(annee, num_partie, instant),
	FOREIGN KEY(type_revirement) REFERENCES type_faute(type),
	FOREIGN KEY(annee, num_partie, instant) REFERENCES action(annee, num_partie, instant)
		ON DELETE CASCADE);

CREATE TABLE faute (annee int, num_partie int, instant time, type_faute char(20),
	PRIMARY KEY(annee, num_partie, instant),
	FOREIGN KEY(type_faute) REFERENCES type_faute(type),
	FOREIGN KEY(annee, num_partie, instant) REFERENCES action(annee, num_partie, instant)
		ON DELETE CASCADE);

CREATE TABLE rebond (annee int, num_partie int, instant time, type_rebond char(20),
	PRIMARY KEY(annee, num_partie, instant),
	FOREIGN KEY(type_rebond) REFERENCES type_faute(type),
	FOREIGN KEY(annee, num_partie, instant) REFERENCES action(annee, num_partie, instant) 
		ON DELETE CASCADE);

CREATE TABLE concoure(annee int, num_partie int, num_equipe_loc int, num_equipe_vis int,
	PRIMARY KEY(annee, num_partie),
	FOREIGN KEY(annee, num_partie) REFERENCES partie(annee, num_partie) ON DELETE CASCADE,
	FOREIGN KEY(num_equipe_loc) REFERENCES equipe(num_equipe) ON DELETE CASCADE,
	FOREIGN KEY(num_equipe_vis) REFERENCES equipe(num_equipe) ON DELETE CASCADE);

CREATE TABLE contrat(num_equipe int, id_joueur int, debut_incl date, fin_excl date, dossard int,
	PRIMARY KEY(num_equipe, id_joueur, debut_incl),
	FOREIGN KEY(id_joueur) REFERENCES joueur(id_joueur) ON DELETE CASCADE,
	FOREIGN KEY(num_equipe) REFERENCES equipe(num_equipe) ON DELETE CASCADE);

delimiter //
CREATE TRIGGER fin_contrat_null
BEFORE INSERT ON contrat
FOR EACH ROW
BEGIN
	IF (NEW.fin_excl = null)
	THEN SET NEW.fin_excl = 9999-12-31;
	END IF;
END;//
delimiter ;

delimiter //
CREATE TRIGGER date_coherentes
BEFORE INSERT ON contrat
FOR EACH ROW
BEGIN
	IF (NEW.fin_excl <> null)
		THEN IF ( NEW.fin_excl <= NEW.debut_incl )
		THEN SET NEW.debut_incl = null;
		END IF;
	END IF;
END;//
delimiter ;

delimiter //
CREATE TRIGGER max_1_contrat_ouvert
BEFORE INSERT ON contrat
FOR EACH ROW
BEGIN
	IF (NEW.fin_excl = null)
		THEN IF (
			SELECT COUNT(*)
			FROM contrat
			WHERE id_joueur = NEW.id_joueur AND fin_excl = null
			) > 0
		THEN SET NEW.debut_incl = null;
		END IF;
	END IF;
END;//
delimiter ;
/*Pas efficace(?), on parcourt tous les contrats du joueur. Devrait prendre + récent(?).
  Pas si grave car joueurs ne devrait pas changer siiii souvent d'équipe
*/

delimiter //
CREATE TRIGGER max_1_dossard
BEFORE INSERT ON contrat
FOR EACH ROW
BEGIN
	IF (NEW.fin_excl = null)
		THEN IF(
			SELECT COUNT(*)
			FROM contrat
			WHERE num_equipe = NEW.num_equipe AND fin_excl > NEW.debut_incl 
				AND dossard = NEW.dossard
			) > 0
		THEN SET NEW.debut_incl = null;
		END IF;
	ELSE IF(SELECT COUNT(*)
		FROM contrat
		WHERE num_equipe = NEW.num_equipe
			AND ((debut_incl between NEW.debut_incl and NEW.fin_excl)
				OR (fin_excl - interval 1 day between NEW.debut_incl  and NEW.fin_excl))
			AND dossard = NEW.dossard
		) > 0
		THEN SET NEW.debut_incl = null;
		END IF;
	END IF;
END;//
delimiter ;
/* Attention, "between __ and __" ne peut aps utiliser d'index sur date
Devrait aps etre grave (pas mettre index), car pas énorméement de changements d'équipes dans 1 carrière.
Équivalent à: " WHERE us_reg_date >= '2000-07-05'
  		AND us_reg_date < '2011-11-10' + interval 1 day "
*/

delimiter //
CREATE TRIGGER max_1_contrat
BEFORE INSERT ON contrat
FOR EACH ROW
BEGIN
IF (NEW.fin_excl = null)
		THEN IF(
			SELECT COUNT(*)
			FROM contrat
			WHERE id_joueur = NEW.id_joueur AND fin_excl > NEW.debut_incl
			) > 0
		THEN SET NEW.debut_incl = null;
		END IF;
ELSE IF (
	SELECT COUNT(*)
	FROM contrat
	WHERE id_joueur = NEW.id_joueur
		AND ((debut_incl between NEW.debut_incl and NEW.fin_excl)
			OR (fin_excl - interval 1 day between NEW.debut_incl  and NEW.fin_excl))
	) > 0
	THEN SET NEW.debut_incl = null;
	END IF;
END IF;
END;//
delimiter ;

CREATE TABLE participe(id_joueur int, annee int, num_partie int, minutes int,
	PRIMARY KEY(annee, num_partie, id_joueur),
	FOREIGN KEY(annee, num_partie) REFERENCES partie(annee, num_partie),
	FOREIGN KEY(id_joueur) REFERENCES joueur(id_joueur));
/* Peut fortement changer
   Trigger: Juste des joueurs d'une des deux équipes
   Ajouter trigger maximum de 12 joueurs par equipe (minimum?-> aucun))
   Potentiellement, faire en même temps (plus efficace)
*/

delimiter //
CREATE TRIGGER joueur_bonne_equipe
BEFORE INSERT ON participe
FOR EACH ROW
BEGIN
IF(  NOT EXISTS(SELECT NULL
     FROM partie P, concoure Cc, contrat Ct
     WHERE P.annee = NEW.annee AND P.num_partie = NEW.num_partie
      AND Cc.annee = NEW.annee AND Cc.num_partie = NEW.num_partie
      AND (Ct.num_equipe = Cc.num_equipe_loc OR Ct.num_equiple = Cc.num_equipe_vis) AND Ct.id_joueur = NEW.id_joueur
      AND Ct.debut_incl <= P.date_partie AND P.date_partie < Ct.fin_excl
    )
)
THEN SET NEW.id_joueur = null;
END IF;
END;//
delimiter ;


delimiter //
CREATE TRIGGER 12_joueurs_par_equipe
BEFORE INSERT ON participe
FOR EACH ROW
BEGIN
IF	(SELECT COUNT(*)
	FROM partie Pe, participe Pp, concoure Cc, contrat Ct
    	WHERE Pe.annee = NEW.annee AND Pe.num_partie = NEW.num_partie
    	 AND Pp.annee = NEW.annee AND Pp.num_partie = NEW.num_partie
     	 AND Cc.annee = NEW.annee AND Cc.num_partie = NEW.num_partie
     	 AND Ct.num_equipe = Cc.num_equipe_loc AND Ct.id_joueur = Pp.id_joueur 
     	 AND Ct.debut_incl <= P.date_partie AND P.date_partie < fin_excl
	) = 12 
THEN SET NEW.id_joueur = null;
END IF;
IF	(SELECT COUNT(*)
	FROM partie Pe, participe Pp, concoure Cc, contrat Ct
    	WHERE Pe.annee = NEW.annee AND Pe.num_partie = NEW.num_partie
    	 AND Pp.annee = NEW.annee AND Pp.num_partie = NEW.num_partie
     	 AND Cc.annee = NEW.annee AND Cc.num_partie = NEW.num_partie
     	 AND Ct.num_equipe = Cc.num_equipe_vis AND Ct.id_joueur = Pp.id_joueur 
     	 AND Ct.debut_incl <= P.date_partie AND P.date_partie < fin_excl
	) = 12 
THEN SET NEW.id_joueur = null;
END IF;
END;//
delimiter ;



show tables;